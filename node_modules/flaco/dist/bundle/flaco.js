var Flaco = (function (exports) {
    'use strict';

    const onNextTick = (fn) => setTimeout(fn, 0);
    const pairify = (holder) => (key) => [key, holder[key]];
    const isShallowEqual = (a, b) => {
        const aKeys = Object.keys(a);
        const bKeys = Object.keys(b);
        return aKeys.length === bKeys.length && aKeys.every(k => a[k] === b[k]);
    };
    // no attributes
    const NA = Object.freeze({});
    const noop = () => {
    };
    const isVTextNode = (vnode) => vnode.nodeType === 'Text';
    const isVNode = (vnode) => typeof vnode !== 'function';
    const isVNodeLike = (input) => !(typeof input === 'object' && input.nodeType === void 0);

    const createTextVNode = (value) => ({
        nodeType: 'Text',
        children: [],
        props: { value },
        lifeCycle: 0
    });
    const normalize = (children, currentText = '', normalized = []) => {
        if (children.length === 0) {
            if (currentText) {
                normalized.push(createTextVNode(currentText));
            }
            return normalized;
        }
        const child = children.shift();
        const type = typeof child;
        if (type === 'object' || type === 'function') {
            if (currentText) {
                normalized.push(createTextVNode(currentText));
                currentText = '';
            }
            normalized.push(child);
        }
        else {
            currentText += child;
        }
        return normalize(children, currentText, normalized);
    };
    function h(nodeType, props, ...children) {
        const actualProps = props === null ? NA : props;
        const flatChildren = [];
        for (const c of children) {
            if (Array.isArray(c)) {
                flatChildren.push(...c);
            }
            else {
                flatChildren.push(c);
            }
        }
        const normalizedChildren = normalize(flatChildren);
        if (typeof nodeType !== 'function') { // Regular html/text node
            return {
                nodeType,
                props: actualProps,
                children: normalizedChildren,
                lifeCycle: 0
            };
        }
        const fullProps = Object.assign({ children: normalizedChildren }, actualProps);
        const comp = nodeType(fullProps);
        const compType = typeof comp;
        return compType !== 'function' ? comp : h(comp, actualProps, ...normalizedChildren); // Functional comp vs combinator (HOC)
    }

    const compose = (first, ...fns) => (...args) => fns.reduce((previous, current) => current(previous), first(...args));
    const curry = (fn, arityLeft) => {
        const arity = arityLeft || fn.length;
        return (...args) => {
            const argLength = args.length || 1;
            if (arity === argLength) {
                return fn(...args);
            }
            const func = (...moreArgs) => fn(...args, ...moreArgs);
            return curry(func, arity - args.length);
        };
    };
    const tap = (fn) => arg => {
        fn(arg);
        return arg;
    };

    const SVG_NP = 'http://www.w3.org/2000/svg';
    var EventSubscriptionMethod;
    (function (EventSubscriptionMethod) {
        EventSubscriptionMethod["removeEventListener"] = "removeEventListener";
        EventSubscriptionMethod["addEventListener"] = "addEventListener";
    })(EventSubscriptionMethod || (EventSubscriptionMethod = {}));
    const updateDomNodeFactory = (method) => (items) => tap(domNode => {
        for (const pair of items) {
            domNode[method](...pair);
        }
    });
    const removeEventListeners = updateDomNodeFactory(EventSubscriptionMethod.removeEventListener);
    const addEventListeners = updateDomNodeFactory(EventSubscriptionMethod.addEventListener);
    const setAttributes = (attributePairs) => tap((dom) => {
        const attributes = attributePairs.filter(([key, value]) => typeof value !== 'function');
        for (const [key, value] of attributes) {
            if (value === false) {
                dom.removeAttribute(key);
            }
            else {
                dom.setAttribute(key, value);
            }
        }
    });
    const removeAttributes = (attributes) => tap((dom) => {
        for (const attr of attributes) {
            dom.removeAttribute(attr);
        }
    });
    const setTextNode = (val) => (node) => {
        node.textContent = val;
    };
    const createDomNode = (vnode, parent) => {
        if (vnode.nodeType === 'svg') {
            return document.createElementNS(SVG_NP, vnode.nodeType);
        }
        else if (vnode.nodeType === 'Text') {
            return document.createTextNode(vnode.nodeType);
        }
        return parent.namespaceURI === SVG_NP ?
            document.createElementNS(SVG_NP, vnode.nodeType) :
            document.createElement(vnode.nodeType);
    };
    // @ts-ignore
    const getEventListeners = (props) => Object.keys(props)
        .filter(k => k.substr(0, 2) === 'on')
        .map(k => [k.substr(2).toLowerCase(), props[k]]);

    function* traverse(vnode) {
        yield vnode;
        if (vnode.children.length > 0) {
            for (const child of vnode.children) {
                yield* traverse(child);
            }
        }
    }

    (function (LifeCycles) {
        LifeCycles["onMount"] = "onMount";
        LifeCycles["onUnMount"] = "onUnMount";
        LifeCycles["onUpdate"] = "onUpdate";
    })(exports.LifeCycles || (exports.LifeCycles = {}));
    const lifeCycleFactory = (method) => curry((fn, comp) => (props, ...args) => {
        const n = comp(props, ...args);
        const applyFn = () => fn(n, ...args);
        const current = n[method];
        n[method] = current ? compose(current, applyFn) : applyFn; // allow multiple hooks;
        return n;
    });
    const onMount = lifeCycleFactory(exports.LifeCycles.onMount);
    const onUnMount = lifeCycleFactory(exports.LifeCycles.onUnMount);
    const onUpdate = lifeCycleFactory(exports.LifeCycles.onUpdate);

    const updateEventListeners = (newNode, oldNode) => {
        const newNodeEvents = getEventListeners(newNode.props);
        const oldNodeEvents = getEventListeners(oldNode.props);
        return newNodeEvents.length || oldNodeEvents.length ?
            compose(removeEventListeners(oldNodeEvents), addEventListeners(newNodeEvents)) : noop;
    };
    const updateAttributes = (newVNode, oldVNode) => {
        const newVNodeProps = newVNode.props;
        const oldVNodeProps = oldVNode.props;
        if (isShallowEqual(newVNodeProps, oldVNodeProps)) {
            return noop;
        }
        if (isVTextNode(newVNode)) {
            return setTextNode(newVNode.props.value);
        }
        const newNodeKeys = Object.keys(newVNodeProps);
        const oldNodeKeys = Object.keys(oldVNodeProps);
        const attributesToRemove = oldNodeKeys.filter(k => !newNodeKeys.includes(k));
        return compose(removeAttributes(attributesToRemove), setAttributes(newNodeKeys.map(pairify(newVNodeProps))));
    };
    const domFactory = createDomNode;
    // Apply vnode diffing to actual dom node (if new node => it will be mounted into the parent)
    const domify = (oldVnode, newVnode, parentDomNode) => {
        if (oldVnode === null && newVnode) { // There is no previous vnode
            newVnode.dom = parentDomNode.appendChild(domFactory(newVnode, parentDomNode));
            newVnode.lifeCycle = 1;
            return { vnode: newVnode, garbage: null };
        }
        // There is a previous vnode
        if (newVnode === null) { // We must remove the related dom node
            parentDomNode.removeChild(oldVnode.dom);
            return ({ garbage: oldVnode, vnode: null });
        }
        else if (newVnode.nodeType !== oldVnode.nodeType) { // It must be replaced (todo check with keys)
            newVnode.dom = domFactory(newVnode, parentDomNode);
            newVnode.lifeCycle = 1;
            parentDomNode.replaceChild(newVnode.dom, oldVnode.dom);
            return { garbage: oldVnode, vnode: newVnode };
        }
        // Only update attributes
        newVnode.dom = oldVnode.dom;
        // Pass the unMountHook
        if (oldVnode.onUnMount) {
            newVnode.onUnMount = oldVnode.onUnMount;
        }
        newVnode.lifeCycle = oldVnode.lifeCycle + 1;
        return { garbage: null, vnode: newVnode };
    };
    const noNode = 'none';
    const falseNode = Object.freeze({
        nodeType: noNode,
        lifeCycle: -1,
        children: [],
        props: {}
    });
    const render = (oldVnode, newVnode, parentDomNode, nextBatchOperations = []) => {
        // 1. transform the new vnode to a vnode connected to an actual dom element based on vnode versions diffing
        // 	i. note at this step occur dom insertions/removals
        // 	ii. it may collect sub tree to be dropped (or "unmounted")
        const { vnode, garbage } = domify(oldVnode, newVnode, parentDomNode);
        if (garbage !== null) {
            // Defer unmount lifecycle as it is not "visual"
            for (const g of traverse(garbage)) {
                if (typeof g[exports.LifeCycles.onUnMount] === 'function') {
                    nextBatchOperations.push(g.onUnMount);
                }
            }
        }
        // Normalisation of old node (in case of a replace we will consider old node as empty node (no children, no props))
        const tempOldNode = garbage !== null || !oldVnode ? falseNode : oldVnode;
        if (vnode !== null) {
            // 2. update dom attributes based on vnode prop diffing.
            // Sync
            if (typeof vnode[exports.LifeCycles.onUpdate] === 'function' && vnode.lifeCycle > 1) {
                vnode.onUpdate();
            }
            updateAttributes(vnode, tempOldNode)(vnode.dom);
            // Fast path
            if (vnode.nodeType === 'Text') {
                return nextBatchOperations;
            }
            if (typeof vnode.onMount === 'function' && vnode.lifeCycle === 1) {
                nextBatchOperations.push(() => vnode.onMount());
            }
            const childrenCount = Math.max(tempOldNode.children.length, vnode.children.length);
            // Async will be deferred as it is not "visual"
            const setListeners = updateEventListeners(vnode, tempOldNode);
            if (setListeners !== noop) {
                nextBatchOperations.push(() => setListeners(vnode.dom));
            }
            // 3. recursively traverse children to update dom and collect functions to process on next tick
            if (childrenCount > 0) {
                for (let i = 0; i < childrenCount; i++) {
                    // We pass nextBatchOperations as reference (improve perf: memory + speed)
                    render(tempOldNode.children[i] || null, vnode.children[i] || null, vnode.dom, nextBatchOperations);
                }
            }
        }
        return nextBatchOperations;
    };
    // todo
    const hydrate = (vnode, dom) => {
        const hydrated = Object.assign({}, vnode);
        const domChildren = Array.from(dom.childNodes).filter((n) => n.nodeType !== 3 || n.nodeValue.trim() !== '');
        hydrated.dom = dom;
        hydrated.children = vnode.children.map((child, i) => hydrate(child, domChildren[i]));
        return hydrated;
    };
    const mount = curry((comp, initProp, root) => {
        const vnode = isVNode(comp) ? comp : comp(initProp || {});
        const oldVNode = root.children.length ? hydrate(vnode, root.children[0]) : null;
        const batch = render(oldVNode, vnode, root);
        onNextTick(() => {
            for (const op of batch) {
                op();
            }
        });
        return vnode;
    });

    const update = (comp, initialVNode) => {
        let oldNode = initialVNode;
        return (props, ...args) => {
            const mountNode = oldNode.dom.parentNode;
            const newNode = comp(Object.assign({}, oldNode.props, props), ...args);
            const nextBatch = render(oldNode, newNode, mountNode);
            // Danger zone !!!!
            // Change by keeping the same reference so the eventual parent node does not need to be "aware" tree may have changed downstream:
            // oldNode may be the child of someone ...(well that is a tree data structure after all :P )
            oldNode = Object.assign(oldNode || {}, newNode);
            // End danger zone
            onNextTick(() => {
                for (const op of nextBatch) {
                    op();
                }
            });
            return newNode;
        };
    };

    const withState = (comp) => (initialState) => {
        let updateFunc;
        // Lazy evaluate updateFunc (to make sure it is defined)
        const wrapperComp = (props, ...args) => {
            const fullProps = Object.assign({}, initialState, props);
            return comp(fullProps, newState => updateFunc(newState), ...args);
        };
        const setUpdateFunction = (vnode) => {
            updateFunc = updateFunc ? updateFunc : update(wrapperComp, vnode);
        };
        return compose(onMount(setUpdateFunction), onUpdate(setUpdateFunction))(wrapperComp);
    };
    const withIdempotentState = (comp) => {
        const instances = new Map();
        return (initialProps) => {
            const { key } = initialProps;
            if (instances.has(key)) {
                return instances.get(key);
            }
            let updateFunc;
            // Lazy evaluate updateFunc (to make sure it is defined)
            const wrapperComp = (props, ...args) => {
                const fullProps = Object.assign({}, initialProps, props);
                return comp(fullProps, newState => updateFunc(newState), ...args);
            };
            const setUpdateFunction = (vnode) => {
                instances.set(key, vnode);
                updateFunc = updateFunc ? updateFunc : update(wrapperComp, vnode);
            };
            const removeInstance = () => instances.delete(key);
            return compose(onMount(setUpdateFunction), onUpdate(setUpdateFunction), onUnMount(removeInstance))(wrapperComp);
        };
    };

    const HTMLElementComponentFactory = (tag) => (props, ...children) => {
        return isVNodeLike(props) ? h(tag, NA, props, ...children) : h(tag, props, ...children);
    };
    // Main root
    // todo
    // Document metadata
    // todo
    // Sectioning root
    const body = HTMLElementComponentFactory('body');
    // Content sectioning
    const address = HTMLElementComponentFactory('address');
    const article = HTMLElementComponentFactory('article');
    const aside = HTMLElementComponentFactory('aside');
    const footer = HTMLElementComponentFactory('footer');
    const header = HTMLElementComponentFactory('header');
    const h1 = HTMLElementComponentFactory('h1');
    const h2 = HTMLElementComponentFactory('h2');
    const h3 = HTMLElementComponentFactory('h3');
    const h4 = HTMLElementComponentFactory('h4');
    const h5 = HTMLElementComponentFactory('h5');
    const h6 = HTMLElementComponentFactory('h6');
    const hgroup = HTMLElementComponentFactory('hgroup');
    const nav = HTMLElementComponentFactory('nav');
    const section = HTMLElementComponentFactory('section');
    // Text content
    const blockquote = HTMLElementComponentFactory('blockquote');
    const dd = HTMLElementComponentFactory('dd');
    const dir = HTMLElementComponentFactory('dir');
    const div = HTMLElementComponentFactory('div');
    const dl = HTMLElementComponentFactory('dl');
    const dt = HTMLElementComponentFactory('dt');
    const figcaption = HTMLElementComponentFactory('figcaption');
    const figure = HTMLElementComponentFactory('figure');
    const hr = HTMLElementComponentFactory('hr');
    const li = HTMLElementComponentFactory('li');
    const main = HTMLElementComponentFactory('main');
    const ol = HTMLElementComponentFactory('ol');
    const p = HTMLElementComponentFactory('p');
    const pre = HTMLElementComponentFactory('pre');
    const ul = HTMLElementComponentFactory('ul');
    // Inline text semantic
    const a = HTMLElementComponentFactory('a');
    const abbr = HTMLElementComponentFactory('abbr');
    const b = HTMLElementComponentFactory('b');
    const bdi = HTMLElementComponentFactory('bdi');
    const bdo = HTMLElementComponentFactory('bdo');
    const br = HTMLElementComponentFactory('br');
    const cite = HTMLElementComponentFactory('cite');
    const quote = HTMLElementComponentFactory('quote');
    const data = HTMLElementComponentFactory('data');
    const dfn = HTMLElementComponentFactory('dfn');
    const em = HTMLElementComponentFactory('em');
    const i = HTMLElementComponentFactory('i');
    const kbd = HTMLElementComponentFactory('kbd');
    const mark = HTMLElementComponentFactory('mark');
    const q = HTMLElementComponentFactory('q');
    const rp = HTMLElementComponentFactory('rp');
    const rt = HTMLElementComponentFactory('rt');
    const rtc = HTMLElementComponentFactory('rtc');
    const ruby = HTMLElementComponentFactory('ruby');
    const s = HTMLElementComponentFactory('s');
    const samp = HTMLElementComponentFactory('samp');
    const small = HTMLElementComponentFactory('small');
    const span = HTMLElementComponentFactory('span');
    const strong = HTMLElementComponentFactory('strong');
    const sub = HTMLElementComponentFactory('sub');
    const sup = HTMLElementComponentFactory('sup');
    const time = HTMLElementComponentFactory('time');
    const u = HTMLElementComponentFactory('u');
    // export const var = (props, ...args) => h('var',props, ...args);
    const wbr = HTMLElementComponentFactory('wbr');
    // Image and multimedia
    const area = HTMLElementComponentFactory('area');
    const audio = HTMLElementComponentFactory('audio');
    const img = HTMLElementComponentFactory('img');
    const map = HTMLElementComponentFactory('map');
    const track = HTMLElementComponentFactory('track');
    const video = HTMLElementComponentFactory('video');
    // Embedded content
    const embed = HTMLElementComponentFactory('embed');
    const object = HTMLElementComponentFactory('object');
    const param = HTMLElementComponentFactory('param');
    const picture = HTMLElementComponentFactory('picture');
    const source = HTMLElementComponentFactory('source');
    // Scripting
    // todo
    // Demarcating edit
    // todo
    // Table content
    const caption = HTMLElementComponentFactory('caption');
    const col = HTMLElementComponentFactory('col');
    const colgroup = HTMLElementComponentFactory('colgroup');
    const table = HTMLElementComponentFactory('table');
    const tbody = HTMLElementComponentFactory('tbody');
    const td = HTMLElementComponentFactory('td');
    const tfoot = HTMLElementComponentFactory('tfoot');
    const th = HTMLElementComponentFactory('th');
    const thead = HTMLElementComponentFactory('thead');
    const tr = HTMLElementComponentFactory('tr');
    // Forms
    const button = HTMLElementComponentFactory('button');
    const datalist = HTMLElementComponentFactory('datalist');
    const fieldset = HTMLElementComponentFactory('fieldset');
    const form = HTMLElementComponentFactory('form');
    const input = HTMLElementComponentFactory('input');
    const label = HTMLElementComponentFactory('label');
    const legend = HTMLElementComponentFactory('legend');
    const meter = HTMLElementComponentFactory('meter');
    const optgroup = HTMLElementComponentFactory('optgroup');
    const option = HTMLElementComponentFactory('option');
    const output = HTMLElementComponentFactory('output');
    const progress = HTMLElementComponentFactory('progress');
    const select = HTMLElementComponentFactory('select');
    const textarea = HTMLElementComponentFactory('textarea');
    // Interactive elements
    // todo

    const filterOutFunction = (props) => Object
        .entries(props || {})
        .filter(([key, value]) => typeof value !== 'function');
    const escapeHTML = s => String(s)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    const renderAsString = curry((comp, initProp) => {
        const vnode = isVNode(comp) ? comp : comp(initProp || {});
        const { nodeType, children, props } = vnode;
        const attributes = escapeHTML(filterOutFunction(props)
            .map(([key, value]) => typeof value === 'boolean' ? (value === true ? key : '') : `${key}="${value}"`)
            .join(' '));
        const childrenHtml = children !== void 0 && children.length > 0 ? children.map(ch => renderAsString(ch)()).join('') : '';
        return isVTextNode(vnode) ? escapeHTML(String(vnode.props.value)) : `<${nodeType}${attributes ? ` ${attributes}` : ''}>${childrenHtml}</${nodeType}>`;
    });

    exports.h = h;
    exports.withState = withState;
    exports.withIdempotentState = withIdempotentState;
    exports.render = render;
    exports.hydrate = hydrate;
    exports.mount = mount;
    exports.body = body;
    exports.address = address;
    exports.article = article;
    exports.aside = aside;
    exports.footer = footer;
    exports.header = header;
    exports.h1 = h1;
    exports.h2 = h2;
    exports.h3 = h3;
    exports.h4 = h4;
    exports.h5 = h5;
    exports.h6 = h6;
    exports.hgroup = hgroup;
    exports.nav = nav;
    exports.section = section;
    exports.blockquote = blockquote;
    exports.dd = dd;
    exports.dir = dir;
    exports.div = div;
    exports.dl = dl;
    exports.dt = dt;
    exports.figcaption = figcaption;
    exports.figure = figure;
    exports.hr = hr;
    exports.li = li;
    exports.main = main;
    exports.ol = ol;
    exports.p = p;
    exports.pre = pre;
    exports.ul = ul;
    exports.a = a;
    exports.abbr = abbr;
    exports.b = b;
    exports.bdi = bdi;
    exports.bdo = bdo;
    exports.br = br;
    exports.cite = cite;
    exports.quote = quote;
    exports.data = data;
    exports.dfn = dfn;
    exports.em = em;
    exports.i = i;
    exports.kbd = kbd;
    exports.mark = mark;
    exports.q = q;
    exports.rp = rp;
    exports.rt = rt;
    exports.rtc = rtc;
    exports.ruby = ruby;
    exports.s = s;
    exports.samp = samp;
    exports.small = small;
    exports.span = span;
    exports.strong = strong;
    exports.sub = sub;
    exports.sup = sup;
    exports.time = time;
    exports.u = u;
    exports.wbr = wbr;
    exports.area = area;
    exports.audio = audio;
    exports.img = img;
    exports.map = map;
    exports.track = track;
    exports.video = video;
    exports.embed = embed;
    exports.object = object;
    exports.param = param;
    exports.picture = picture;
    exports.source = source;
    exports.caption = caption;
    exports.col = col;
    exports.colgroup = colgroup;
    exports.table = table;
    exports.tbody = tbody;
    exports.td = td;
    exports.tfoot = tfoot;
    exports.th = th;
    exports.thead = thead;
    exports.tr = tr;
    exports.button = button;
    exports.datalist = datalist;
    exports.fieldset = fieldset;
    exports.form = form;
    exports.input = input;
    exports.label = label;
    exports.legend = legend;
    exports.meter = meter;
    exports.optgroup = optgroup;
    exports.option = option;
    exports.output = output;
    exports.progress = progress;
    exports.select = select;
    exports.textarea = textarea;
    exports.update = update;
    exports.renderAsString = renderAsString;
    exports.onMount = onMount;
    exports.onUnMount = onUnMount;
    exports.onUpdate = onUpdate;

    return exports;

}({}));
//# sourceMappingURL=flaco.js.map
